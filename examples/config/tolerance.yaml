# PyPEEC tolerance data for the solver:
#   - define the numerical options for the discretization
#   - define the numerical options for the matrix multiplication
#   - define the numerical options for the FFT algorithm
#   - define the numerical options for the sparse matrix factorization
#   - define the numerical options for the iterative solver
#   - define the numerical options for the matrix condition check
#
# Thomas Guillod - Dartmouth College
# Mozilla Public License Version 2.0

# control where numerical approximations are used for the Green and coupling functions
#   - if the normalized voxel distance is smaller than the threshold, analytical solutions are used
#   - if the normalized voxel distance is larger than the threshold, numerical approximations are used
"green_simplify": 20.0
"coupling_simplify": 20.0

# method for dense matrix multiplication
#   - "fft" for doing the multiplication with circulant tensors and FFT
#   - "direct" for standard matrix multiplication
#   - "direct" is extremely slow and memory intensive
#   - "direct" is only useful for debugging and educational purposes
"mult_type": "fft"

# FFT algorithm options
"fft_options":
    # handling of the tensors for the FFT
    #   - if true, the computation is done with the 4D tensors
    #   - if false, the 4D tensors are sliced into several 3D tensors
    #   - splitting the tensors has a slightly increased computational cost
    #   - splitting the tensors reduces the memory footprint of the computation
    "matrix_split": true               # handling of the tensors for the FFT
    # FFT library
    #   - "SciPy" FFT library is always available (integrated with SciPy)
    #   - "FFTW" has to be installed separately (available through pyFFTW)
    #   - "CuPy" is extremely fast but require GPUs compatible with the CUDA toolkit.
    "library": "SciPy"                 # FFT library
    "scipy_worker": null               # number of workers for SciPy (null for number of CPUs)
    "fftw_thread": null                # number of threads for FFTW (null for number of CPUs)
    "fftw_timeout": 100.0              # cache timeout in seconds for FFTW (null for no caching)
    "fftw_byte_align": 16              # size for byte alignment FFTW (null for default)

# sparse matrix factorization options
"factorization_options":
    # matrix factorization library
    #   - "SuperLU" is typically slower but is always available (integrated with SciPy)
    #   - "UMFPACK" is typically faster than SuperLU (available through SciKits)
    #   - "PARDISO" is typically faster than UMFPACK (available through Pydiso)
    #   - "PyAMG" is typically slow but uses less memory (risk of convergence issues)
    "library": "SuperLU"               # matrix factorization library
    "pyamg_options":                   # options for PyAMG
        "tol": 1.0e-6                  # tolerance for the AMG solver convergence
        "solver": "root"               # name of the AMG solver ("adapt" or "root")
        "krylov": null                 # use acceleration method (null or "gmres" or "fgmres")
    "pardiso_options":                 # options for PARDISO
        "thread_pardiso": null         # number of threads for PARDISO (null for number of CPUs)
        "thread_mkl": null             # number of threads for MKL (null for number of CPUs)

# iterative solver options (for GMRES and GCROT solver)
"solver_options":
    "check": true                      # check (or not) the solver tolerance
    "tolerance": 1.0e-6                # tolerance for checking the solution residuum
    "iter_options":                    # options for the iterative solver
        "solver": "gmres"              # name of the solver ("gmres" or "gcrot")
        "rel_tol": 1.0e-6              # relative preconditioned tolerance for solver convergence
        "abs_tol": 1.0e-12             # absolute preconditioned tolerance for solver convergence
        "n_inner": 20                  # maximum number of solver inner iterations
        "n_outer": 20                  # maximum number of solver outer iterations

# matrix condition check options
"condition_options":
    "check": true                      # check (or not) the condition number of the matrices
    "tolerance": 1.0e+15               # maximum allowable condition number for the matrices
    "norm_options":                    # options for computing the one-norm estimate
        "t_accuracy": 2                # accuracy parameter for the one-norm estimate
        "n_iter_max": 25               # maximum number of iterations for the one-norm estimate
